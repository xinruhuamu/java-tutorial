1.过滤器和拦截器都是面向切面编程的具体体现。
  1、Filter是依赖于Servlet容器，属于Servlet规范的一部分，而拦截器则是独立存在的，可以在任何情况下使用。
  2、Filter的执行由Servlet容器回调完成，而拦截器通常通过动态代理的方式来执行。
  3、Filter的生命周期由Servlet容器管理，而拦截器则可以通过IoC容器来管理，因此可以通过注入等方式来获取其他Bean的实例，因此使用会更方便。


过滤器依赖于servlet容器，是JavaEE标准，在请求进入容器之后，还未进入Servlet之前进行预处理，并且在请求结束返回给前端这之间进行后期处理。
在实现上基于函数回调，可以对几乎所有请求进行过滤，但是缺点是一个过滤器实例只能在容器初始化时调用一次。使用过滤器的目的是用来做一些过滤操作。
过滤器可以简单理解为“取你所想取”，忽视掉那些你不想要的东西，比如：在过滤器中修改字符编码；在过滤器中修改HttpServletRequest的一些参数，包括：过滤低俗文字、危险字符等。

拦截器不依赖与servlet容器，依赖于web框架。在SpringMVC中就是依赖于SpringMVC框架，在SSH框架中，就是依赖于Struts框架。在实现上基于Java的反射机制，属于面向切面编程（AOP）的一种运用。
由于拦截器是基于web框架的调用，因此可以使用spring的依赖注入（DI）获取IOC容器中的各个bean,进行一些业务操作，同时一个拦截器实例在一个controller生命周期之内可以多次调用。
但是缺点是只能对controller请求进行拦截，即⑴请求还没有到controller层时进行拦截，⑵请求走出controller层次，还没有到渲染时图层时进行拦截，⑶结束视图渲染，但是还没有到servlet的结束时进行拦截。
对其他的一些比如直接访问静态资源的请求则没办法进行拦截处理,拦截器功在对请求权限鉴定方面确实很有用处。它可以简单理解为“拒你所想拒”。



监听器->过滤器->servlet容器->DispatcherServlet->拦截器->controller
过滤器和拦截器的区别：
    ①、过滤器是基于函数回调，拦截器基于Java的反射机制。
    ②、过滤器依赖于servlet容器，拦截器不依赖于servlet容器，而依赖web框架。
    ③、过滤器对所有请求起作用，拦截器只能对action请求起作用（因为依赖web框架）。
    ④、过滤器不能访问action上下文、值栈里的对象，拦截器可以。
    ⑤、在action声明周期内，过滤器只在容器初始化时被调用一次，拦截器可以多次被调用。
    ⑥、过滤器不能获取IOC容器中的bean，拦截器可以，所以，在拦截器中注入一个service可以调用业务逻辑。

使用方法：
通过实现HandlerInterceptor接口或者继承HandlerInterceptorAdapter类完成自定义

preHandle、postHandle与afterCompletion
preHandle
调用时间：Controller方法处理之前
执行顺序：链式Intercepter情况下，Intercepter按照声明的顺序一个接一个执行
若返回false，则中断执行，注意：不会进入afterCompletion

postHandle
调用前提：preHandle返回true
调用时间：Controller方法处理完之后，DispatcherServlet进行视图的渲染之前，也就是说在这个方法中你可以对ModelAndView进行操作
执行顺序：链式Intercepter情况下，Intercepter按照声明的顺序倒着执行。
备注：postHandle虽然post打头，但post、get方法都能处理

afterCompletion
调用前提：preHandle返回true
调用时间：DispatcherServlet进行视图的渲染之后
多用于清理资源
