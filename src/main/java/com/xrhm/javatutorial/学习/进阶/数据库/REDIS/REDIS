REDIS是一种基于内存的、存储键值对的非关系型数据库，读写速度快，广泛用于缓存。

https://zh.wikipedia.org/wiki/Redis
1.什么是Redis？
Remote Dictionary Service，远程字典服务。
基于内存的，存储键值对的非关系型数据库；存储中间件。
用作数据库、缓存和中间件。

2.Redis的数据类型
五种，字符串string，列表list，散列（哈希）hash，集合set，有序集合zset

3.使用Redis的好处
速度快。
4.Redis相比MemCached的区别有哪些？相比有哪些优势？
相同点：都可以存储键值对；性能高；
不同点：Redis基于单进程、单线程，MemCached基于单进程、多线程；Redis除了可以存储字符串外，还可以存储其他4种数据结构；Redis能够自动将两种不同的方式将数据存进硬盘。
支持更广泛的业务需求。
注：Mysql是单进程、多线程的数据库。

5.Redis是单进程、单线程的吗？
是，Redis是基于内存的单进程、单线程的键值数据库。
Redis内部实际并不只有一个主线程，还有几个异步线程专门处理一些耗时操作。
6.Redis中，一个字符串string类型的值能存储的最大容量是多少？
512MB。
A String value can be at max 512 Megabytes in length.

7.Redis的持久化机制是什么？有什么优缺点？
https://segmentfault.com/a/1190000012908434
Redis支持RDB和AOF两种持久化机制。
RDB持久化：指定时间间隔对数据进行快照存储。
AOF持久化：记录每次对服务器的写操作，当服务器重启的时候重新执行这些命令恢复原始的数据。

8.Redis常见性能问题和解决方案


9.Redis过期键的删除策略是什么？
https://www.cnblogs.com/xuliangxing/p/7151812.html
3种过期策略。
Redis采用了其中两种：惰性删除和定期删除。

定时删除：集中删除
    设置key的过期时间时，Redis会将每个设置了过期时间的key放入独立的字典中；并设置定时器，定时遍历字典并删除其中到期的key。
    优点：因为到期马上删除，保证内存尽快释放。
    缺点：因为Redis单线程，如果过期key过多，删除key会占用CPU时间；定时器创建耗时多，为每个每个设置过期时间的key创建定时器，产生大量定时器。


惰性删除：零散删除
    key过期时不马上删除，当客户端访问Redis获取key的时候检查是否过期，若过期，则删除，返回null。
    优点：删除操作发生在客户端获取key的时候，删除操作对CPU占用时间少。
    缺点：若大量过期的key，长时间没被获取，那么可能发生内存泄漏（无用垃圾占用内存）。

定期删除：
    每隔一段时间执行一次删除过期key操作（默认10次/s，可在redis.conf设置hz频率）
    定时扫描方法：
        Redis 默认会每秒进行十次过期扫描，过期扫描不会遍历过期字典中所有的 key，而是采用了一种简单的贪心策略。
        1、从过期字典中随机 20 个 key；
        2、删除这 20 个 key 中已经过期的 key；
        3、如果过期的 key 比率超过 1/4，那就重复步骤 1；
        同时，为了保证过期扫描不会出现循环过度，导致线程卡死现象，算法还增加了扫描时间的上限，默认不会超过 25ms。
    优点：通过限制删除操作时长和频率，减少删除操作对CPU时间的占用；还可以定期删除过期key，减少无用垃圾占用内存。
    缺点：中庸，内存友好不如定时删除，CPU时间友好不如惰性删除。
    难点：合理设置删除操作执行时长和执行频率。

？？？从库的过期策略？？？？？？？？

10.Redis的回收策略（淘汰策略）是什么？
指Redis的用于缓存的内存不足时，处理回收旧数据的方法。
Redis的内存淘汰策略的选取并不会影响过期的key的处理。内存淘汰策略用于处理内存不足时的需要申请额外空间的数据；过期策略用于处理过期的缓存数据。
LRU是Redis唯一支持的回收算法。
Redis 使用的并不是完全LRU算法，而是采用类似LRU算法。自动驱逐的 key , 并不一定是最满足LRU特征的那个. 而是通过近似LRU算法, 抽取少量的 key 样本, 然后删除其中访问时间最古老的那个key。

Redis3.0支持6种淘汰策略：
    noeviction 不会继续服务写请求 (DEL 请求可以继续服务)，读请求可以继续进行。这样
    可以保证不会丢失数据，但是会让线上的业务不能持续进行。这是默认的淘汰策略。
    volatile-lru 尝试淘汰设置了过期时间的 key，最少使用的 key 优先被淘汰。没有设置过
    期时间的 key 不会被淘汰，这样可以保证需要持久化的数据不会突然丢失。
    volatile-ttl 跟上面一样，除了淘汰的策略不是 LRU，而是 key 的剩余寿命 ttl 的值，ttl
    越小越优先被淘汰。
    volatile-random 跟上面一样，不过淘汰的 key 是过期 key 集合中随机的 key。
    allkeys-lru 区别于 volatile-lru，这个策略要淘汰的 key 对象是全体的 key 集合，而不
    只是过期的 key 集合。这意味着没有设置过期时间的 key 也会被淘汰。
    allkeys-random 跟上面一样，不过淘汰的策略是随机的 key。
    volatile-xxx 策略只会针对带过期时间的 key 进行淘汰，allkeys-xxx 策略会对所有的
    key 进行淘汰。如果你只是拿 Redis 做缓存，那应该使用 allkeys-xxx，客户端写缓存时
    不必携带过期时间。如果你还想同时使用 Redis 的持久化功能，那就使用 volatile-xxx
    策略，这样可以保留没有设置过期时间的 key，它们是永久的 key 不会被 LRU 算法淘
    汰。


11.为什么Redis把数据放进内存中？
速度快。


12.Redis主从同步机制是什么？
Redis的主从同步机制可确保Redis的master和slave之间的数据同步；Redis2.8及以上版本使用psync命令完成主从数据同步。同步方法：全量复制和增量复制。


13.Pipeline的用处，有什么优点？

14.Redis集群的原理是什么？

15.Redis集群方案什么时候会导致集群不可用？

16.Redis支持的Java客户端有哪些？官方推荐哪个？

17.Jedis与Redisson对比有哪些优缺点？

18.Redis如何设置密码和验证密码？

19.Redis哈希槽的概念