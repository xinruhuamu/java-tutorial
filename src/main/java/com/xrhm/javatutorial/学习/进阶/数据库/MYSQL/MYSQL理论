1.数据库连接url
jdbc:mysql://localhost:3306/sakila_c?useSSL=false&useUnicode=true&characterEncoding=UTF-8&serverTimezone=GMT
1.mysql执行流程
连接器->解析器->优化器->执行器
连接器：管理连接、权限验证
分析器：词法分析、语法分析；mysql查询缓存在8.0已删除
优化器：执行计划生成、索引选择
执行器：操作引擎，返回结果

2.事务隔离 https://zh.wikipedia.org/wiki/%E4%BA%8B%E5%8B%99%E9%9A%94%E9%9B%A2  关键词：MVCC、RC、RR
Mysql数据库为保证事务transaction准确性的4个特性ACID：A(Atomicity)原子性，C(Consistency)一致性，I(Isolation)隔离性，D(Durability)持久性。
原子性：一个事务中的所有操作，或者全部完成， 或者全部不完成，不会在中间的某个环节中断结束。如果事务在执行过程中发生错误，会回滚Rollback到事务开始前的状态。即事务不可分割、不可约简。
一致性：在事务开始之前和事务结束之后，数据库的完整性没有被破坏。所有操作必须完全符合所有的预设约束、触发器、级联回滚等。（不太懂）
隔离性：数据库允许多个事务并发执行，隔离性防止多个事务并发执行时由于交叉执行导致的不一致。事务隔离级别（从低到高）分为：读未提交Read Uncommitted、读提交Read Committed、可重复读Repeatable Reads、串行化Serializable。
    Mysql Innodb默认隔离级别是可重复读Repeatable Reads。 DBMS：database management system
    a.读未提交Read Uncommitted：最低隔离级别，允许"脏读"。一个事务未提交时，它的变更、修改就会被别的事务看到、读取。比如数据库中A的值为1，事务1查询A的值，事务2将A的值修改为A=2，那么事务2在执行过程中对事务1是透明可读取的，那么即使事务2未完成提交，
    事务1也会在过程中获取A=2.
    b.读提交Read Committed：一个事务提交之后，它的变更才会被其他事务看到、读取。基于锁机制并发控制的DBMS需要对选定对象的【写锁】一直保持到事务结束，但是【读锁】在SELECT操作完成后马上释放（因此"不可重复读"现象可能会发生），
    和 可重复读Repeatable Reads、串行化Serializable一样，不要求"范围锁"。
    c.可重复读Repeatable Reads:一个事务执行过程中看到的数据，总是和这个事务启动时看到的数据是一致的。同样的，在可重复读隔离级别下，未提交的事务变更对其他事务也是不可见的。在此隔离级别中，基于锁机制并发控制的DBMS需要对选定对象的读锁【read clocks】
    和写锁【write locks】一直保持到事务结束，但是不要求"范围锁"，因此可能会发生"幻读"。
    d.串行化Serializable:最高隔离级别，对于同一行记录，"写"会加"写锁"，"读"会加"读锁"。当出现读写锁冲突时，后访问的事务必须等前一个事务执行完成才能继续执行。
    在基于锁机制并发控制的DBMS实现可串行化，要求在选定对象上的读锁和写锁保持直到事务结束后才能释放。在SELECT 的查询中使用一个“WHERE”子句来描述一个范围时应该获得一个“范围锁”（range-locks）。这种机制可以避免“幻读”（phantom reads）现象。

    脏读(Dirty reads)：当一个事务1被允许读取另一个事务2修改但未提交的数据时，如果另一个事务2发生回滚，则可能发生脏读。一般发生在"读未提交"隔离级别中。
    脏读和不可重复读（non-repeatable reads）类似。事务2没有提交造成事务1的语句1两次执行得到不同的结果集。在未提交读隔离级别唯一禁止的是更新混乱，即早期的更新可能出现在后来更新之前的结果集中。
    在我们的例子中，事务2修改了一行，但是没有提交，事务1读了这个没有提交的数据。现在如果事务2回滚了刚才的修改或者做了另外的修改的话，事务1中查到的数据就是不正确的了。

    不可重复读(non-repeatable reads):和dirty reads类似。在一次事务中，当一行数据获取2遍得到不同的结果，表示发生了"不可重复读"。一般发生在"读未提交"和"读提交"隔离级别中。
    在基于锁的并发控制中“不可重复读”现象发生在当执行SELECT 操作时没有获得读锁或者SELECT操作执行完后马上释放了读锁； 多版本并发控制中当没有要求一个提交冲突(commit conflict)的事务回滚也会发生“不可重复读”现象。

    幻读(phantom read):在事务执行过程中，当两个完全相同的查询语句执行得到不同的结果集，称为幻读。


持久性：事务执行结束后，对数据的修改时永久的，即使发生故障也不会丢失。（个人理解：因为数据写入硬盘了。）

3.索引
数据库中一个排序的数据结构，协助快速查询、更新数据库表数据，提高查询效率。

常见三种模型：哈希表、有序数组、二叉搜索树。
哈希表：一种以键-值（key-value）格式数据的结构（具体讲解可以查看算法中的哈希表介绍）。因为哈希表不是有序的，所以哈希索引做区间查询的速度很慢；这种结构适用于只有等值查询的场景，例如Memcached及一些NoSql引擎。
有序数组：在等值查询和范围查询场景都非常优秀。有序数组的插入更新代价太高，适用于静态存储引擎。
二叉搜索树：

Mysql中的索引：
Mysql中索引在存储引擎层实现。InnoDB使用B+树 索引模型，数据存储在B+数中。（关于B+的介绍，可以查看数据结构中介绍。）

4.数据库中的锁（可以和事务隔离建立联系）关键词：快照读、当前读、MVCC、ReadView
在RU下，读取不加锁，修改加锁。RC、RR下，快照读时，使用MVCC保证并发；当前读时，使用锁保证并发。

根据加锁的范围，Mysql中的锁大致分为全局锁、表锁、行锁三种。
全局锁：对整个数据库加锁。使用场景是全库逻辑备份。

表锁：MyISAM和InnoDB引擎均支持表锁（这里主要介绍InnoDB引擎）。
表锁是Mysql最基本的锁策略，开销小，加锁快，无死锁，粒度大
a.MyISAM引擎下的表锁（大致介绍）：
MyISAM执行查询前自动给涉及的所有表加读锁；执行删改查前加写锁。

b.InnoDB引擎下的表锁（默认可重复读事务隔离级别RR）：
注：InnoDB默认使用行锁，因为高并发的需求。
InnoDB使用表锁的场景：
    RR下，InnoDB使用快照读（普通Select）会开启ReadView（consistent read view，一致性读），不加锁，使用MVCC机制防止脏读、不可重复读、幻读。
          使用当前读（select...for update、update、delete、insert）不启用ReadView，使用锁保证并发操作准确性。此时，如果通过索引检索数据会加行锁，
          没有索引的话会降级到表锁，其他事务无法对当前表进行更新和插入操作，影响并发行性能。

行锁：MyISAM引擎不支持行锁；InnoDB支持行锁，InnoDB的行锁是基于索引的，只有通过索引条件检索数据才会使用行锁 。行锁针对数据表中行记录。
InnoDB引擎下的行锁：InnoDB默认行锁，因此支持高并发。
RR下，当前读如果没有使用索引，行锁会降级为表锁。
如果使用唯一索引且命中，InnoDB只会锁住当前记录；如果使用非唯一索引及范围查询时，命中多行记录，均会加锁，称为间隙锁（Gap-lock）。
共享锁：share lock，读锁。
排它锁：exclusive lock，写锁。


在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时commit才释放。这个就是两阶段锁协议（两阶段锁可能导致死锁）。

死锁：不同线程中出现循环资源依赖，涉及的线程互相等待别的线程释放资源，会出现线程进入无线等待的状态，称为死锁。
死锁检测：

5.普通索引和唯一索引的选择
建议选择普通索引（主要考虑更新 的性能影响）。
原因:a.查询过程中，普通索引和唯一索引性能差距微小。  b.更新过程中，唯一索引需要判断是否冲突，对内存和硬盘io的访问增多，性能比普通索引差；
    但是，如果业务需求要唯一，就要用唯一。

6.关系型数据库三范式  举例https://blog.csdn.net/dancheren/article/details/77891426
1NF：数据库表的每一列都不可再分割。
2NF：实体属性完全依赖于主键【消除部分子函数依赖】。
3NF：实体属性不依赖于其它非主属性【消除传递依赖】。








