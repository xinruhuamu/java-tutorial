1.数据库连接url
jdbc:mysql://localhost:3306/sakila_c?useSSL=false&useUnicode=true&characterEncoding=UTF-8&serverTimezone=GMT
1.mysql执行流程
连接器->解析器->优化器->执行器
连接器：管理连接、权限验证
解析器：词法分析、语法分析；mysql查询缓存在8.0已删除
优化器：执行计划生成、索引选择
执行器：操作引擎，返回结果

2.事务隔离 https://zh.wikipedia.org/wiki/%E4%BA%8B%E5%8B%99%E9%9A%94%E9%9B%A2  关键词：MVCC、RC、RR
Mysql数据库为保证事务transaction准确性的4个特性ACID：A(Atomicity)原子性，C(Consistency)一致性，I(Isolation)隔离性，D(Durability)持久性。
原子性：一个事务中的所有操作，或者全部完成， 或者全部不完成，不会在中间的某个环节中断结束。如果事务在执行过程中发生错误，会回滚Rollback到事务开始前的状态。即事务不可分割、不可约简。
一致性：在事务开始之前和事务结束之后，数据库的完整性没有被破坏。所有操作必须完全符合所有的预设约束、触发器、级联回滚等。（不太懂）
隔离性：数据库允许多个事务并发执行，隔离性防止多个事务并发执行时由于交叉执行导致的不一致。事务隔离级别（从低到高）分为：读未提交Read Uncommitted、读提交Read Committed、可重复读Repeatable Reads、串行化Serializable。
    Mysql Innodb默认隔离级别是可重复读Repeatable Reads。 DBMS：database management system
    a.读未提交Read Uncommitted：最低隔离级别，允许"脏读"。一个事务未提交时，它的变更、修改就会被别的事务看到、读取。比如数据库中A的值为1，事务1查询A的值，事务2将A的值修改为A=2，那么事务2在执行过程中对事务1是透明可读取的，那么即使事务2未完成提交，
    事务1也会在过程中获取A=2.
    b.读提交Read Committed：一个事务提交之后，它的变更才会被其他事务看到、读取。基于锁机制并发控制的DBMS需要对选定对象的【写锁】一直保持到事务结束，但是【读锁】在SELECT操作完成后马上释放（因此"不可重复读"现象可能会发生），
    和 可重复读Repeatable Reads、串行化Serializable一样，不要求"范围锁"。
    c.可重复读Repeatable Reads:一个事务执行过程中看到的数据，总是和这个事务启动时看到的数据是一致的。同样的，在可重复读隔离级别下，未提交的事务变更对其他事务也是不可见的。在此隔离级别中，基于锁机制并发控制的DBMS需要对选定对象的读锁【read clocks】
    和写锁【write locks】一直保持到事务结束，但是不要求"范围锁"，因此可能会发生"幻读"。
    d.串行化Serializable:最高隔离级别，对于同一行记录，"写"会加"写锁"，"读"会加"读锁"。当出现读写锁冲突时，后访问的事务必须等前一个事务执行完成才能继续执行。
    在基于锁机制并发控制的DBMS实现可串行化，要求在选定对象上的读锁和写锁保持直到事务结束后才能释放。在SELECT 的查询中使用一个“WHERE”子句来描述一个范围时应该获得一个“范围锁”（range-locks）。这种机制可以避免“幻读”（phantom reads）现象。

并发事务的问题：
    脏读(Dirty reads)：当一个事务1被允许读取另一个事务2修改但未提交的数据时，如果另一个事务2发生回滚，则可能发生脏读。一般发生在"读未提交"隔离级别中。
    脏读和不可重复读（non-repeatable reads）类似。事务2没有提交造成事务1的语句1两次执行得到不同的结果集。在未提交读隔离级别唯一禁止的是更新混乱，即早期的更新可能出现在后来更新之前的结果集中。
    在我们的例子中，事务2修改了一行，但是没有提交，事务1读了这个没有提交的数据。现在如果事务2回滚了刚才的修改或者做了另外的修改的话，事务1中查到的数据就是不正确的了。

    丢失修改：当一个事务修改一个数据时，另外一个事务也访问修改了该数据，那么在第一个事务修改数据之后，第二个事务也修改了数据，导致第一个事务的修改结果被丢失。
     例如：事务1读取某表中的数据A=20，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改被丢失。

    不可重复读(non-repeatable reads):和dirty reads类似。在一次事务中，当一行数据获取2遍得到不同的结果，表示发生了"不可重复读"。一般发生在"读未提交"和"读提交"隔离级别中。
    在基于锁的并发控制中“不可重复读”现象发生在当执行SELECT 操作时没有获得读锁或者SELECT操作执行完后马上释放了读锁； 多版本并发控制中当没有要求一个提交冲突(commit conflict)的事务回滚也会发生“不可重复读”现象。

    幻读(phantom read):在事务执行过程中，当两个完全相同的查询语句执行得到不同的结果集，称为幻读。


持久性：事务执行结束后，对数据的修改时永久的，即使发生故障也不会丢失。（个人理解：因为数据写入硬盘了。）

注意：与 SQL 标准不同的地方在于 InnoDB 存储引擎在 REPEATABLE-READ（可重读） 事务隔离级别下使用的是Next-Key Lock 锁算法，因此可以避免幻读的产生，
这与其他数据库系统(如 SQL Server) 是不同的。所以说InnoDB 存储引擎的默认支持的隔离级别是 REPEATABLE-READ（可重读） 已经可以完全保证事务的隔离性要求，
即达到了 SQL标准的 SERIALIZABLE(可串行化) 隔离级别。因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是 READ-COMMITTED(读取提交内容) ，
但是你要知道的是InnoDB 存储引擎默认使用 REPEAaTABLE-READ（可重读） 并不会有任何性能损失。
InnoDB 存储引擎在 分布式事务 的情况下一般会用到 SERIALIZABLE(可串行化) 隔离级别。

3.索引
数据库中一个排序的数据结构，协助快速查询、更新数据库表数据，提高查询效率。

a.常见三种模型：哈希表、有序数组、二叉搜索树。
哈希表：一种以键-值（key-value）格式数据的结构（具体讲解可以查看算法中的哈希表介绍）。因为哈希表不是有序的，所以哈希索引做区间查询的速度很慢；这种结构适用于只有等值查询的场景，例如Memcached及一些NoSql引擎。
有序数组：在等值查询和范围查询场景都非常优秀。有序数组的插入更新代价太高，适用于静态存储引擎。
二叉搜索树：

b.Mysql中的索引：
Mysql中索引在存储引擎层实现。InnoDB使用B+树 索引模型，数据存储在B+树中。（关于B+的介绍，可以查看数据结构中介绍。）

c.InnoDB使用B+树索引
根据索引树的叶子节点内容，索引类型分为主键索引（聚簇索引）和非主键索引（非聚簇索引、二级索引）
主键索引的叶子节点存的是整行数据（叶子节点是page页，一个页有多个行）。在 InnoDB 里，主键索引也被称为聚簇索引（clustered index）。有且只有一个。
非主键索引的叶子节点内容是主键的值。在 InnoDB 里，非主键索引也被称为二级索引（secondary index）。

基于非主键索引的查询需要多扫描一棵索引树（被称为回表，先二级索引查询主键的值，再通过主键索引搜索树），因此尽量使用主键索引（可以使用联合索引）。

4.回表和索引覆盖
a.回表
通过非主键索引查询数据时，先在非主键索引树上查询到数据在主键索引上的地址，然后回到主键索引树上搜索数据，称为回表。
如果直接使用主键索引查询，则不需要回表。

如何避免回表？索引覆盖
b.索引覆盖
无需回表，只要搜索一次索引树就可以获取到数据，减少查询次数，提高查询性能。
索引覆盖的方法：建立联合索引。

c.最左前缀原则
主要使用在联合索引中。


5.普通索引和唯一索引的选择
建议选择普通索引（主要考虑更新 的性能影响）。
原因:a.查询过程中，普通索引和唯一索引性能差距微小。  b.更新过程中，唯一索引需要判断是否冲突，对内存和硬盘io的访问增多，性能比普通索引差；
    但是，如果业务需求要唯一，就要用唯一。

6.重建索引
索引可能因为删除或者页分裂等原因，需要重建索引。
如果需要重建索引，尽量不要重建主键索引，因为无论删除还是创建主键，整个表都会重建。
========================================================================================================================

6.数据库中的锁（可以和事务隔离建立联系）关键词：快照读、当前读、MVCC、ReadView
在RU下，读取不加锁，修改加锁。RC、RR下，快照读时，使用MVCC保证并发；当前读时，使用锁保证并发。

根据加锁的范围，Mysql中的锁大致分为全局锁、表锁、行锁三种。
全局锁：对整个数据库加锁。使用场景是全库逻辑备份。

表锁：MyISAM和InnoDB引擎均支持表锁（这里主要介绍InnoDB引擎）。
表锁是Mysql最基本的锁策略，开销小，加锁快，无死锁，粒度大
a.MyISAM引擎下的表锁（大致介绍）：
MyISAM执行查询前自动给涉及的所有表加读锁；执行删改查前加写锁。

b.InnoDB引擎下的表锁（默认可重复读事务隔离级别RR）：
注：InnoDB默认使用行锁，因为高并发的需求。
InnoDB使用表锁的场景：
    RR下，InnoDB使用快照读（普通Select）会开启ReadView（consistent read view，一致性读），不加锁，使用MVCC机制防止脏读、不可重复读、幻读。
          使用当前读（select...for update、update、delete、insert）不启用ReadView，使用锁保证并发操作准确性。此时，如果通过索引检索数据会加行锁，
          没有索引的话会降级到表锁，其他事务无法对当前表进行更新和插入操作，影响并发行性能。

行锁：MyISAM引擎不支持行锁；InnoDB支持行锁，InnoDB的行锁是基于索引的，只有通过索引条件检索数据才会使用行锁 。行锁针对数据表中行记录。
InnoDB引擎下的行锁：InnoDB默认行锁，因此支持高并发。
RR下，当前读如果没有使用索引，行锁会降级为表锁。
如果使用唯一索引且命中，InnoDB只会锁住当前记录，Record lock；如果使用非唯一索引及范围查询时，命中多行记录（不包括记录本身），均会加锁，称为间隙锁（Gap-lock）。

InnoDB存储引擎的锁的算法有三种：
Record lock：单个行记录上的锁
Gap lock：间隙锁，锁定一个范围，不包括记录本身
Next-key lock：record+gap 锁定一个范围，包含记录本身

锁的概念：
共享锁：share lock，读锁s锁。
排它锁：exclusive lock，写锁x锁。

在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时commit才释放。这个就是两阶段锁协议（两阶段锁可能导致死锁）。

死锁：不同线程中出现循环资源依赖，涉及的线程互相等待别的线程释放资源，会出现线程进入无线等待的状态，称为死锁。
死锁检测：


7.关系型数据库三范式  举例https://blog.csdn.net/dancheren/article/details/77891426
1NF：数据库表的每一列都不可再分割。
2NF：实体属性完全依赖于主键【消除部分子函数依赖】。
3NF：实体属性不依赖于其它非主属性【消除传递依赖】。

8.大表的优化
当MySql单表数据过大时，CURD性能明显下降，常见优化措施：
a.限定数据范围
禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询订单历史的时候，我们可以控制在一个月的范围内；

b.读写分离
数据库拆分方案，主库负责写，从库负责读。

c.垂直分区
指数据表列的拆分，把列较多的表拆分成多表。

d.水平分区
保持数据表结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中，达到了分布式的目的。 水平拆分可以支撑非常大的数据量。

尽量不要对数据进行分片，因为拆分会带来逻辑、部署、运维的各种复杂度

9.InnoDB引擎下的COUNT()
COUNT()是一个聚合函数，对于返回的结果集一行一行判断，如果COUNT的参数不是NULL，累计值加1，否则不加。最后返回累计值。
count(*)、count(主键 id) 和 count(1) 都表示返回满足条件的结果集的总行数；而 count(字段），则表示返回满足条件的数据行里面，参数“字段”不为 NULL 的总个数。
a.
b.COUNT(主键id)，InnoDB 引擎会遍历整张表，把每一行的 id 值都取出来，返回给 server 层。server 层拿到 id 后，判断是不可能为空的，就按行累加。
c.COUNT(1)，InnoDB 引擎遍历整张表，但不取值。server 层对于返回的每一行，放一个数字“1”进去，判断是不可能为空的，按行累加。
d.COUNT(字段)如果这个“字段”是定义为 not null 的话，一行行地从记录里面读出这个字段，判断不能为 null，按行累加；如果这个“字段”定义允许为 null，
那么执行的时候，判断到有可能是 null，还要把值取出来再判断一下，不是 null 才累加。

按照效率排序的话，count(字段)<count(主键 id)<count(1)≈count(*)，所以尽量使用 count(*)。






























